<emu-clause id="sec-properties-of-the-array-constructor">
  <h1>Properties of the Array Constructor</h1>
  <emu-clause id="sec-array.from">
    <h1>Array.from ( _items_ [ , _mapfn_ [ , _thisArg_ ] ] )</h1>
    <p>When the `from` method is called with argument _items_ and optional arguments _mapfn_ and _thisArg_, the following steps are taken:</p>
    <emu-alg>
      1. Let _C_ be the *this* value.
      1. <del>If _mapfn_ is *undefined*, let _mapping_ be *false*.</del>
      1. <del>Else,</del>
        1. <del>If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.</del>
        1. <del>If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.</del>
        1. <del>Let _mapping_ be *true*.</del>
      1. <del>Let _usingIterator_ be ? GetMethod(_items_, @@iterator).</del>
      1. <del>If _usingIterator_ is not *undefined*, then</del>
        1. <del>If IsConstructor(_C_) is *true*, then</del>
          1. <del>Let _A_ be ? Construct(_C_).</del>
        1. <del>Else,</del>
          1. <del>Let _A_ be ! ArrayCreate(0).</del>
        1. <del>Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~, _usingIterator_).</del>
        1. <del>Let _k_ be 0.</del>
        1. <del>Repeat,</del>
          1. <del>If _k_ &ge; 2<sup>53</sup> - 1, then</del>
            1. <del>Let _error_ be ThrowCompletion(a newly created *TypeError* object).</del>
            1. <del>Return ? IteratorClose(_iteratorRecord_, _error_).</del>
          1. <del>Let _Pk_ be ! ToString(_k_).</del>
          1. <del>Let _next_ be ? IteratorStep(_iteratorRecord_).</del>
          1. <del>If _next_ is *false*, then</del>
            1. <del>Perform ? Set(_A_, `"length"`, _k_, *true*).</del>
            1. <del>Return _A_.</del>
          1. <del>Let _nextValue_ be ? IteratorValue(_next_).</del>
          1. <del>If _mapping_ is *true*, then</del>
            1. <del>Let _mappedValue_ be Call(_mapfn_, _T_, &laquo; _nextValue_, _k_ &raquo;).</del>
            1. <del>If _mappedValue_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _mappedValue_).</del>
            1. <del>Set _mappedValue_ to _mappedValue_.[[Value]].</del>
          1. <del>Else, let _mappedValue_ be _nextValue_.</del>
          1. <del>Let _defineStatus_ be CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).</del>
          1. <del>If _defineStatus_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _defineStatus_).</del>
          1. <del>Increase _k_ by 1.</del>
      1. <del>NOTE: _items_ is not an Iterable so assume it is an array-like object.</del>
      1. <del>Let _arrayLike_ be ! ToObject(_items_).</del>
      1. <del>Let _len_ be ? ToLength(? Get(_arrayLike_, `"length"`)).</del>
      1. <del>If IsConstructor(_C_) is *true*, then</del>
        1. <del>Let _A_ be ? Construct(_C_, &laquo; _len_ &raquo;).</del>
      1. <del>Else,</del>
        1. <del>Let _A_ be ? ArrayCreate(_len_).</del>
      1. <del>Let _k_ be 0.</del>
      1. <del>Repeat, while _k_ &lt; _len_</del>
        1. <del>Let _Pk_ be ! ToString(_k_).</del>
        1. <del>Let _kValue_ be ? Get(_arrayLike_, _Pk_).</del>
        1. <del>If _mapping_ is *true*, then</del>
          1. <del>Let _mappedValue_ be ? Call(_mapfn_, _T_, &laquo; _kValue_, _k_ &raquo;).</del>
        1. <del>Else, let _mappedValue_ be _kValue_.</del>
        1. <del>Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).</del>
        1. <del>Increase _k_ by 1.</del>
      1. <del>Perform ? Set(_A_, `"length"`, _len_, *true*).</del>
      1. <del>Return _A_.</del>
      1. <ins>Return ? ArrayFrom(_items_, _C_, _mapfn_, _thisArg_).</ins>
    </emu-alg>
    <emu-clause id="sec-arrayfrom" aoid="ArrayFrom">
      <h1><ins>ArrayFrom ( _items_ [ , _C_ [ , _mapfn_ [ , _thisArg_ ] ] ] )</ins></h1>
      <p>The abstract operation ArrayFrom with arguments _items_, _C_, _mapfn_, and _thisArg_ performs the following steps:</p>
      <emu-alg>
        1. If _mapfn_ is *undefined*, let _mapping_ be *false*.
        1. Else,
          1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.
          1. If _thisArg_ is present, let _T_ be _thisArg_; else let _T_ be *undefined*.
          1. Let _mapping_ be *true*.
        1. Let _usingIterator_ be ? GetMethod(_items_, @@iterator).
        1. If _usingIterator_ is not *undefined*, then
          1. If IsConstructor(_C_) is *true*, then
            1. Let _A_ be ? Construct(_C_).
          1. Else,
            1. Let _A_ be ! ArrayCreate(0).
          1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~, _usingIterator_).
          1. Let _k_ be 0.
          1. Repeat,
            1. If _k_ &ge; 2<sup>53</sup> - 1, then
              1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
              1. Return ? IteratorClose(_iteratorRecord_, _error_).
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _next_ be ? IteratorStep(_iteratorRecord_).
            1. If _next_ is *false*, then
              1. Perform ? Set(_A_, `"length"`, _k_, *true*).
              1. Return _A_.
            1. Let _nextValue_ be ? IteratorValue(_next_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be Call(_mapfn_, _T_, &laquo; _nextValue_, _k_ &raquo;).
              1. If _mappedValue_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _mappedValue_).
              1. Set _mappedValue_ to _mappedValue_.[[Value]].
            1. Else, let _mappedValue_ be _nextValue_.
            1. Let _defineStatus_ be CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
            1. If _defineStatus_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _defineStatus_).
            1. Increase _k_ by 1.
        1. NOTE: _items_ is not an Iterable so assume it is an array-like object.
        1. Let _arrayLike_ be ! ToObject(_items_).
        1. Let _len_ be ? ToLength(? Get(_arrayLike_, `"length"`)).
        1. If IsConstructor(_C_) is *true*, then
          1. Let _A_ be ? Construct(_C_, &laquo; _len_ &raquo;).
        1. Else,
          1. Let _A_ be ? ArrayCreate(_len_).
        1. Let _k_ be 0.
        1. Repeat, while _k_ &lt; _len_
          1. Let _Pk_ be ! ToString(_k_).
          1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
          1. If _mapping_ is *true*, then
            1. Let _mappedValue_ be ? Call(_mapfn_, _T_, &laquo; _kValue_, _k_ &raquo;).
          1. Else, let _mappedValue_ be _kValue_.
          1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
          1. Increase _k_ by 1.
        1. Perform ? Set(_A_, `"length"`, _len_, *true*).
        1. Return _A_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>