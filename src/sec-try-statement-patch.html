<emu-clause id="sec-try-statement">
  <h1>The `try` Statement</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    TryStatement[Yield, Await, Return] :
      <ins>`try` `(` [lookahead âˆ‰ { `let [` }] Expression[+In, ?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]? Finally[?Yield, ?Await, ?Return]?</ins>
      <ins>`try` `(` `var` VariableDeclarationList[+In, ?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]? Finally[?Yield, ?Await, ?Return]?</ins>
      <ins>`try` `(` LetOrConst BindingList[+In, ?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]? Finally[?Yield, ?Await, ?Return]?</ins>
      `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
      `try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
      `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
  </emu-grammar>
</emu-clause>

<emu-clause id="sec-try-statement-static-semantics-early-errors">
  <h1>Static Semantics: Early Errors</h1>
  <emu-grammar>
    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block</ins>
    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch</ins>
    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Finally</ins>
    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch Finally</ins>
  </emu-grammar>
  <ul>
    <li>
      It is a Syntax Error if any element of the BoundNames of |BindingList| also occurs in the VarDeclaredNames of |Block|.
    </li>
  </ul>
</emu-clause>

<emu-clause id="sec-try-statement-static-semantics-containsduplicatelabels">
  <h1>Static Semantics: ContainsDuplicateLabels</h1>
  <p>With parameter _labelSet_.</p>
  <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>
  <emu-grammar>
    <ins>TryStatement : `try` `(` Expression `)` Block</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block</ins>
  </emu-grammar>
  <emu-alg>
    1. Return ContainsDuplicateLabels of |Block| with argument _labelSet_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch

    <ins>TryStatement : `try` `(` Expression `)` Block Catch</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
    1. If _hasDuplicates_ is *true*, return *true*.
    1. Return ContainsDuplicateLabels of |Catch| with argument _labelSet_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Finally</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
    1. If _hasDuplicates_ is *true*, return *true*.
    1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Catch Finally</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
    1. If _hasDuplicates_ is *true*, return *true*.
    1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Catch| with argument _labelSet_.
    1. If _hasDuplicates_ is *true*, return *true*.
    1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.
  </emu-alg>
  <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
  <emu-alg>
    1. Return ContainsDuplicateLabels of |Block| with argument _labelSet_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-try-statement-static-semantics-containsundefinedbreaktarget">
  <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>
  <p>With parameter _labelSet_.</p>
  <emu-see-also-para op="ContainsUndefinedBreakTarget"></emu-see-also-para>
  <emu-grammar>
    <ins>TryStatement : `try` `(` Expression `)` Block</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block</ins>
  </emu-grammar>
  <emu-alg>
    1. Return ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch

    <ins>TryStatement : `try` `(` Expression `)` Block Catch</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
    1. If _hasUndefinedLabels_ is *true*, return *true*.
    1. Return ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Finally</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
    1. If _hasUndefinedLabels_ is *true*, return *true*.
    1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Catch Finally</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
    1. If _hasUndefinedLabels_ is *true*, return *true*.
    1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_.
    1. If _hasUndefinedLabels_ is *true*, return *true*.
    1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.
  </emu-alg>
  <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
  <emu-alg>
    1. Return ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-try-statement-static-semantics-containsundefinedcontinuetarget">
  <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>
  <p>With parameters _iterationSet_ and _labelSet_.</p>
  <emu-see-also-para op="ContainsUndefinedContinueTarget"></emu-see-also-para>
  <emu-grammar>
    <ins>TryStatement : `try` `(` Expression `)` Block</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block</ins>
  </emu-grammar>
  <emu-alg>
    1. Return ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch

    <ins>TryStatement : `try` `(` Expression `)` Block Catch</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
    1. If _hasUndefinedLabels_ is *true*, return *true*.
    1. Return ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and &laquo; &raquo;.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Finally</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
    1. If _hasUndefinedLabels_ is *true*, return *true*.
    1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and &laquo; &raquo;.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Catch Finally</ins>

    <ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
    1. If _hasUndefinedLabels_ is *true*, return *true*.
    1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and &laquo; &raquo;.
    1. If _hasUndefinedLabels_ is *true*, return *true*.
    1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and &laquo; &raquo;.
  </emu-alg>
  <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
  <emu-alg>
    1. Return ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and &laquo; &raquo;.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-try-statement-static-semantics-vardeclarednames">
  <h1>Static Semantics: VarDeclaredNames</h1>
  <emu-see-also-para op="VarDeclaredNames"></emu-see-also-para>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block</ins></emu-grammar>
  <emu-alg>
    1. Let _names_ be BoundNames of |VariableDeclarationList|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Block|.
    1. Return _names_.
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch</ins></emu-grammar>
  <emu-alg>
    1. Let _names_ be BoundNames of |VariableDeclarationList|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Block|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Catch|.
    1. Return _names_.
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _names_ be BoundNames of |VariableDeclarationList|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Block|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Finally|.
    1. Return _names_.
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _names_ be BoundNames of |VariableDeclarationList|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Block|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Catch|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Finally|.
    1. Return _names_.
  </emu-alg>
  <emu-grammar>
    <ins>TryStatement : `try` `(` Expression `)` Block</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block</ins>
  </emu-grammar>
  <emu-alg>
    1. Return the VarDeclaredNames of |Block|.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch

    <ins>TryStatement : `try` `(` Expression `)` Block Catch</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _names_ be VarDeclaredNames of |Block|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Catch|.
    1. Return _names_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _names_ be VarDeclaredNames of |Block|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Finally|.
    1. Return _names_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Catch Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _names_ be VarDeclaredNames of |Block|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Catch|.
    1. Append to _names_ the elements of the VarDeclaredNames of |Finally|.
    1. Return _names_.
  </emu-alg>
  <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
  <emu-alg>
    1. Return the VarDeclaredNames of |Block|.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-try-statement-static-semantics-varscopeddeclarations">
  <h1>Static Semantics: VarScopedDeclarations</h1>
  <emu-see-also-para op="VarScopedDeclarations"></emu-see-also-para>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block</ins></emu-grammar>
  <emu-alg>
    1. Let _declarations_ be VarScopedDeclarations of |VariableDeclarationList|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Block|.
    1. Return _declarations_.
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch</ins></emu-grammar>
  <emu-alg>
    1. Let _declarations_ be VarScopedDeclarations of |VariableDeclarationList|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Block|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Catch|.
    1. Return _declarations_.
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _declarations_ be VarScopedDeclarations of |VariableDeclarationList|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Block|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Finally|.
    1. Return _declarations_.
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _declarations_ be VarScopedDeclarations of |VariableDeclarationList|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Block|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Catch|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Finally|.
    1. Return _declarations_.
  </emu-alg>
  <emu-grammar>
    <ins>TryStatement : `try` `(` Expression `)` Block</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block</ins>
  </emu-grammar>
  <emu-alg>
    1. Return the VarScopedDeclarations of |Block|.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch

    <ins>TryStatement : `try` `(` Expression `)` Block Catch</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _declarations_ be VarScopedDeclarations of |Block|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Catch|.
    1. Return _declarations_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _declarations_ be VarScopedDeclarations of |Block|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Finally|.
    1. Return _declarations_.
  </emu-alg>
  <emu-grammar>
    TryStatement : `try` Block Catch Finally

    <ins>TryStatement : `try` `(` Expression `)` Block Catch Finally</ins>

    <ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch Finally</ins>
  </emu-grammar>
  <emu-alg>
    1. Let _declarations_ be VarScopedDeclarations of |Block|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Catch|.
    1. Append to _declarations_ the elements of the VarScopedDeclarations of |Finally|.
    1. Return _declarations_.
  </emu-alg>
  <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
  <emu-alg>
    1. Return the VarScopedDeclarations of |Block|.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-static-semantics-tryresources" aoid="TryResources">
  <h1><ins>Static Semantics: TryResources</ins></h1>
  <emu-grammar>
    VariableDeclarationList: VariableDeclarationList `,` VariableDeclaration
  </emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of |VariableDeclarationList|.
    1. Append to _resources_ the elements of the TryResources of |VariableDeclaration|.
    1. Return _resources_.
  </emu-alg>
  <emu-grammar>
    VariableDeclarationList: VariableDeclaration
  </emu-grammar>
  <emu-alg>
    1. Return &laquo; |VariableDeclaration| &raquo;
  </emu-alg>
  <emu-grammar>
    BindingList: BindingList `,` LexicalBinding
  </emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of |BindingList|.
    1. Append to _resources_ the elements of the TryResources of |LexicalBinding|.
    1. Return _resources_.
  </emu-alg>
  <emu-grammar>
    BindingList: LexicalBinding
  </emu-grammar>
  <emu-alg>
    1. Return &laquo; |LexicalBinding| &raquo;
  </emu-alg>
</emu-clause>

<emu-clause id="sec-runtime-semantics-trywithresourcesinstantiation" aoid="TryWithResourcesInstantiation">
  <h1><ins>Runtime Semantics: TryWithResourcesInstantiation (_boundName_, _declarationKind_, _tryEnv_)</ins></h1>
  <p>The abstract operation TryWithResourcesInstantiation with arguments _boundName_, _declarationKind_ and _tryEnv_ performs the following steps:</p>
  <emu-alg>
    1. Assert: _tryEnv_ is a Lexical Environment.
    1. Assert: Type(_boundName_) is String or Undefined.
    1. Assert: _declarationKind_ is `"none"`, `"var"`, `"let"` or `"const"`.
    1. If _declarationKind_ is `"const"` or `"let"`, then
      1. Assert: Type(_boundName_) is String.
      1. Let _envRec_ be _tryEnv_'s EnvironmentRecord.
      1. Assert: _envRec_ is a declarative EnvironmentRecord.
      1. If _declarationKind_ is `"const"`, then
        1. Perfom ! _envRec_.CreateImmutableBinding(_boundName_, *true*).
      1. Else,
        1. Perfom ! _envRec_.CreateMutableBinding(_boundName_, *false*).
  </emu-alg>
</emu-clause>

<emu-clause id="sec-runtime-semantics-tryresourceevaluation" aoid="TryResourceEvaluation">
  <h1><ins>Runtime Semantics: TryResourceEvaluation (_resource_, _boundName_, _declarationKind_)</ins></h1>
  <p>The abstract operation TryResourceEvaluation with arguments _resource_, _boundName_ and _declarationKind_ performs the following steps:</p>
  <emu-alg>
    1. Assert: _declarationKind_ is `"none"`, `"var"`, `"let"`, or `"const"`.
    1. If _declarationKind_ is `"none"`, then
      1. Assert: _resource_ is an |Expression|.
      1. Assert: _boundName_ is *undefined*.
      1. Let _exprRef_ be the result of evaluating _resource_.
      1. Return ? GetValue(_exprRef_).
    1. Else,
      1. Assert: _resource_ is a |VariableDeclaration| or a |LexicalBinding|.
      1. Assert: Type(_boundName_) is String.
      1. Let _decl_ be the result of evaluating _resource_.
      1. ReturnIfAbrupt(_decl_).
      1. Return ? ResolveBinding(_boundName_).
  </emu-alg>
</emu-clause>

<emu-clause id="sec-runtime-semantics-trywithresourcesevaluation" aoid="TryWithResourcesEvaluation">
  <h1><ins>Runtime Semantics: TryWithResourcesEvaluation (_resources_, _boundNames_, _declarationKind_, _depth_)</ins></h1>
  <p>With arguments _resources_, _boundNames_, _declarationKind_ and _depth_.</p>
  <emu-grammar>
    TryStatement : `try` `(` Expression `)` Block Catch? Finally?
    TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch? Finally?
    TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch? Finally?
  </emu-grammar>
  <emu-alg>
    1. Assert: _resources_ is a non-empty List.
    1. Assert: _boundNames_ is a List.
    1. Assert: _declarationKind_ is `"none"`, `"var"`, `"let"`, or `"const"`.
    1. Let _maxDepth_ be the number of elements in _resources_.
    1. Assert: 0 &le; _depth_ &lt; _maxDepth_.
    1. Let _resource_ be the element at index _depth_ of _resources_.
    1. If _declarationKind_ is `"none"`, then
      1. Let _boundName_ be *undefined*.
    1. Else,
      1. Assert: The number of elements in _boundNames_ is equal to _maxDepth_.
      1. Let _boundName_ be the element at index _depth_ of _boundNames_.
    1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
    1. Let _tryEnv_ be NewDeclarativeEnvironment(_oldEnv_).
    1. Perform TryWithResourcesInstantiation(_boundName_, _declarationKind_, _tryEnv_).
    1. Set the running execution context's LexicalEnvironment to _tryEnv_.
    1. Let _exprCompletion_ be TryResourceEvaluation(_resource_, _boundName_).
    1. If _exprCompletion_.[[Type]] is not ~normal~, then
      1. Set the running execution context's LexicalEnvironment to _oldEnv_.
      1. Return _exprCompletion_.
    1. If _depth_ &lt; _maxDepth_ - 1, then
      1. Let _result_ be TryWithResourcesEvaluation(_resources_, _boundNames_, _declarationKind_, _depth_ + 1).
    1. Else,
      1. Let _result_ be the result of evaulating |Block|.
    1. Let _expr_ be _exprCompletion_.[[Value]].
    1. If _expr_ is *null* or *undefined*, then
      1. Let _cleanupResult_ be NormalCompletion(~empty~).
    1. Else,
      1. Let _cleanupResult_ be Invoke(_expr_, @@dispose).
    1. Set the running execution context's LexicalEnvironment to _oldEnv_.
    1. If _cleanupResult_.[[Type]] is ~throw~, then
      1. If _result_.[[Type]] is ~throw~, then
        1. Let _errors_ be CreateArrayFromList(&laquo; _result_.[[Value]], _cleanupResult_.[[Value]] &raquo;).
        1. Throw a new *AggregateError* exception the errors in _errors_.
      1. Else,
        1. Return _cleanupResult_.
    1. Else,
      1. Assert: _cleanupResult_.[[Type]] is ~normal~.
    1. Return _result_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-try-statement-runtime-semantics-evaluation">
  <h1>Runtime Semantics: Evaluation</h1>
  <emu-grammar><ins>TryStatement : `try` `(` Expression `)` Block</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be &laquo; |Expression| &raquo;.
    1. Return ? TryWithResourcesEvaluation(_resources_, &laquo; &raquo;, `"none"`, `0`).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` Expression `)` Block Catch</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be &laquo; |Expression| &raquo;.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, &laquo; &raquo;, `"none"`, `0`).
    1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
    1. Else, let _C_ be _B_.
    1. Return Completion(UpdateEmpty(_C_, *undefined*)).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` Expression `)` Block Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be &laquo; |Expression| &raquo;.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, &laquo; &raquo;, `"none"`, `0`).
    1. Let _F_ be the result of evaluating |Finally|.
    1. If _F_.[[Type]] is ~normal~, set _F_ to _B_.
    1. Return Completion(UpdateEmpty(_F_, *undefined*)).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` Expression `)` Block Catch Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be &laquo; |Expression| &raquo;.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, &laquo; &raquo;, `"none"`, `0`).
    1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
    1. Else, let _C_ be _B_.
    1. Let _F_ be the result of evaluating |Finally|.
    1. If _F_.[[Type]] is ~normal~, set _F_ to _C_.
    1. Return Completion(UpdateEmpty(_F_, *undefined*)).
  </emu-alg>

  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of |VariableDeclarationList|.
    1. Let _boundNames_ be the BoundNames of |VariableDeclarationList|.
    1. Return ? TryWithResourcesEvaluation(_resources_, _boundName_, `"var"`, `0`).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of |VariableDeclarationList|.
    1. Let _boundNames_ be the BoundNames of |VariableDeclarationList|.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, _boundName_, `"var"`, `0`).
    1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
    1. Else, let _C_ be _B_.
    1. Return Completion(UpdateEmpty(_C_, *undefined*)).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of |VariableDeclarationList|.
    1. Let _boundNames_ be the BoundNames of |VariableDeclarationList|.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, _boundName_, `"var"`, `0`).
    1. Let _F_ be the result of evaluating |Finally|.
    1. If _F_.[[Type]] is ~normal~, set _F_ to _B_.
    1. Return Completion(UpdateEmpty(_F_, *undefined*)).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` `var` VariableDeclarationList `)` Block Catch Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of |VariableDeclarationList|.
    1. Let _boundNames_ be the BoundNames of |VariableDeclarationList|.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, _boundName_, `"var"`, `0`).
    1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
    1. Else, let _C_ be _B_.
    1. Let _F_ be the result of evaluating |Finally|.
    1. If _F_.[[Type]] is ~normal~, set _F_ to _C_.
    1. Return Completion(UpdateEmpty(_F_, *undefined*)).
  </emu-alg>

  <emu-grammar><ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of BindingList.
    1. Let _boundNames_ be the BoundNames of BindingList.
    1. If IsConstantDeclaration of |LetOrConst| is *true*, let _declarationKind_ be `"const"`.
    1. Else, let _declarationKind_ be `"let"`.
    1. Return ? TryWithResourcesEvaluation(_resources_, _boundName_, _declarationKind_, `0`).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of BindingList.
    1. Let _boundNames_ be the BoundNames of BindingList.
    1. If IsConstantDeclaration of |LetOrConst| is *true*, let _declarationKind_ be `"const"`.
    1. Else, let _declarationKind_ be `"let"`.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, _boundName_, _declarationKind_, `0`).
    1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
    1. Else, let _C_ be _B_.
    1. Return Completion(UpdateEmpty(_C_, *undefined*)).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of BindingList.
    1. Let _boundNames_ be the BoundNames of BindingList.
    1. If IsConstantDeclaration of |LetOrConst| is *true*, let _declarationKind_ be `"const"`.
    1. Else, let _declarationKind_ be `"let"`.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, _boundName_, _declarationKind_, `0`).
    1. Let _F_ be the result of evaluating |Finally|.
    1. If _F_.[[Type]] is ~normal~, set _F_ to _B_.
    1. Return Completion(UpdateEmpty(_F_, *undefined*)).
  </emu-alg>
  <emu-grammar><ins>TryStatement : `try` `(` LetOrConst BindingList `)` Block Catch Finally</ins></emu-grammar>
  <emu-alg>
    1. Let _resources_ be TryResources of BindingList.
    1. Let _boundNames_ be the BoundNames of BindingList.
    1. If IsConstantDeclaration of |LetOrConst| is *true*, let _declarationKind_ be `"const"`.
    1. Else, let _declarationKind_ be `"let"`.
    1. Let _B_ be TryWithResourcesEvaluation(_resources_, _boundName_, _declarationKind_, `0`).
    1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
    1. Else, let _C_ be _B_.
    1. Let _F_ be the result of evaluating |Finally|.
    1. If _F_.[[Type]] is ~normal~, set _F_ to _C_.
    1. Return Completion(UpdateEmpty(_F_, *undefined*)).
  </emu-alg>

  <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
  <emu-alg>
    1. Let _B_ be the result of evaluating |Block|.
    1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
    1. Else, let _C_ be _B_.
    1. Return Completion(UpdateEmpty(_C_, *undefined*)).
  </emu-alg>
  <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
  <emu-alg>
    1. Let _B_ be the result of evaluating |Block|.
    1. Let _F_ be the result of evaluating |Finally|.
    1. If _F_.[[Type]] is ~normal~, set _F_ to _B_.
    1. Return Completion(UpdateEmpty(_F_, *undefined*)).
  </emu-alg>
  <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
  <emu-alg>
    1. Let _B_ be the result of evaluating |Block|.
    1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with argument _B_.[[Value]].
    1. Else, let _C_ be _B_.
    1. Let _F_ be the result of evaluating |Finally|.
    1. If _F_.[[Type]] is ~normal~, set _F_ to _C_.
    1. Return Completion(UpdateEmpty(_F_, *undefined*)).
  </emu-alg>
</emu-clause>
